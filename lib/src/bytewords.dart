import 'package:hex/hex.dart';
import 'dart:typed_data';

import 'package:flutter/foundation.dart';

import 'utils.dart';

const bytewords =
    'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';
List<int> bytewordsLookUpTable = [];
const BYTEWORDS_NUM = 256;
const BYTEWORD_LENGTH = 4;
const MINIMAL_BYTEWORD_LENGTH = 2;

enum Styles {
  standard,
  uri,
  minimal,
}

String getWord(int index) {
  return bytewords.substring(
      index * BYTEWORD_LENGTH, (index * BYTEWORD_LENGTH) + BYTEWORD_LENGTH);
}

String getMinimalWord(int index) {
  final byteword = getWord(index);

  return '${byteword[0]}${byteword[BYTEWORD_LENGTH - 1]}';
}

String addCRC(String str) {
  final crc = getCRCHex(HEX.decode(str) as Uint8List);

  return '$str$crc';
}

String encodeWithSeparator(String word, String separator) {
  final crcAppendedWord = addCRC(word);
  final crcWordBuff = HEX.decode(crcAppendedWord) as Uint8List;
  final result = crcWordBuff.fold<List<String>>(
      [], (result, w) => [...result, getWord(w)]);

  return result.join(separator);
}

String encodeMinimal(String word) {
  final crcAppendedWord = addCRC(word);
  final crcWordBuff = HEX.decode(crcAppendedWord) as Uint8List;
  final result = crcWordBuff.fold<String>('', (result, w) => result + getMinimalWord(w));

  return result;
}

String decodeWord(String word, int wordLength) {
  assert(word.length == wordLength,
      'Invalid Bytewords: word.length does not match wordLength provided');

  const dim = 26;

  // Since the first and last letters of each Byteword are unique,
  // we can use them as indexes into a two-dimensional lookup table.
  // This table is generated lazily.
  if (bytewordsLookUpTable.isEmpty) {
    const arrayLen = dim * dim;
    bytewordsLookUpTable = List.filled(arrayLen, -1);

    for (var i = 0; i < BYTEWORDS_NUM; i++) {
      final byteword = getWord(i);
      final x = byteword.codeUnitAt(0) - 'a'.codeUnitAt(0);
      final y = byteword.codeUnitAt(3) - 'a'.codeUnitAt(0);
      final offset = y * dim + x;
      bytewordsLookUpTable[offset] = i;
    }
  }

  // If the coordinates generated by the first and last letters are out of bounds,
  // or the lookup table contains -1 at the coordinates, then the word is not valid.
  final x = word[0].toLowerCase().codeUnitAt(0) - 'a'.codeUnitAt(0);
  final y = word[wordLength == 4 ? 3 : 1].toLowerCase().codeUnitAt(0) -
      'a'.codeUnitAt(0);

  assert(0 <= x && x < dim && 0 <= y && y < dim,
      'Invalid Bytewords: invalid word');

  final offset = y * dim + x;
  final value = bytewordsLookUpTable[offset];

  assert(value != -1, 'Invalid Bytewords: value not in lookup table');

  // If we're decoding a full four-letter word, verify that the two middle letters are correct.
  if (wordLength == BYTEWORD_LENGTH) {
    final byteword = getWord(value);
    final c1 = word[1].toLowerCase();
    final c2 = word[2].toLowerCase();

    assert(c1 == byteword[1] && c2 == byteword[2],
        'Invalid Bytewords: invalid middle letters of word');
  }

  // Successful decode.
  return HEX.encode(Uint8List.fromList([value]));
}

String _decode(String str, String separator, int wordLength) {
  final words = wordLength == BYTEWORD_LENGTH
      ? str.split(separator)
      : partition(str, 2);
  final decodedString = words
      .map((word) => decodeWord(word, wordLength))
      .join('');

  assert(decodedString.length >= 5,
      'Invalid Bytewords: invalid decoded string length');

  final body = HEX.decode(decodedString.substring(0, decodedString.length - 8)) as Uint8List;
  final bodyChecksum = decodedString.substring(decodedString.length - 8);

  final checksum = getCRCHex(body);

  assert(checksum == bodyChecksum, 'Invalid Checksum');

  return HEX.encode(body);
}

String decode(String str, {Styles style = Styles.minimal}) {
  switch (style) {
    case Styles.standard:
      return _decode(str, ' ', BYTEWORD_LENGTH);
    case Styles.uri:
      return _decode(str, '-', BYTEWORD_LENGTH);
    case Styles.minimal:
      return _decode(str, '', MINIMAL_BYTEWORD_LENGTH);
    default:
      throw ArgumentError('Invalid style $style');
  }
}

String encode(String str, {Styles style = Styles.minimal}) {
  switch (style) {
    case Styles.standard:
      return encodeWithSeparator(str, ' ');
    case Styles.uri:
      return encodeWithSeparator(str, '-');
    case Styles.minimal:
      return encodeMinimal(str);
    default:
      throw ArgumentError('Invalid style $style');
  }
}